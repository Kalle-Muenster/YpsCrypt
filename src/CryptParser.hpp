/*///////////////////////////////////////////////////////////*\
||                                                           ||
||     File:      CryptParser.hpp                            ||
||     Author:    autogenerated                              ||
||     Generated: by Command Generator v.0.1                 ||
||                                                           ||
\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
#ifndef _CryptParser_hpp_
#define _CryptParser_hpp_

namespace Yps {    

	value struct CryptFrame;

	generic<class E>
	public interface class IParser
	{
	public:
		property bool Found { virtual bool get(void) abstract; }
		property int Offset { virtual int get(void) abstract; }

		// translate an enumerators actual index position to a byte
		// index position where last found search text match begins
		int  FoundAt(int actualEnumeratorPosition) abstract;

		// setup a search 'verb' which makes enumerator stopping
		// as soon matching sequence of elements is found in data  
		void    SetSequence(int number, Object^ sequence) abstract;
		void    AddSequence(Object^ sequence) abstract;
		Object^ GetSequence(int number) abstract;

		// get that search sequence which the enumerator just found
		// or (if enumerator not has found anything yet) empty sequence
		Object^ GetSequence(void) abstract;

		// number of search verbs which had been set up by using 
		// AddSequence() or by Construction parameter 'sequences'
		property int VerbsCount { virtual int get(void) abstract; }

		property int FoundCount { virtual int get(void) abstract; }

		// Prepares the search parser for searching for further 
		// ocurrences of same search verb after finding a match
		int Next(void) abstract;

		// parses the next element ('Current' element) in progress
		// returns: 'true' if search text is encounterd. otherwise 'false'.
		bool Parse(E next) abstract;

		// same like Parse() does, but returns just the passed current
		// element as is. information about serach text was encounterd
		// can be obtained via the 'Found' property which turns 'true' 
		// as soon search text was encountered.
		E Check(E next) abstract;
	};

	generic<class T>
	public ref class SearchSequences
	{
	private:

		int          foundIndex;
		List<int>^ foundFrame;

	internal:

		List<T>^ sequences;
		Action<int>^ trigger;
		T            nuller;

		property int found {
			int get(void) { return foundIndex; }
			void set(int value) {
				if (value != foundIndex) {
					if (value < 0 && foundFrame->Count > 0)
						foundFrame->RemoveAt(0);
				} foundIndex = value;
			}
		}

		void incrementfound() {
			foundFrame->Add(0);
			for (int i = 0; i < foundFrame->Count - 1; ++i)
				foundFrame[i + 1] = foundFrame[i];
		}

		property int foundCount {
			int get(void) { return foundFrame->Count; }
		}

		property int actual {
			int get(void) { return foundFrame[0]; }
			void set(int value) {
				foundFrame[0] = value;
			}
		}

	public:

		SearchSequences(Action<int>^ notify, T nuller) {
			sequences = gcnew List<T>(1);
			this->nuller = nuller;
			trigger = notify;
			foundIndex = -1;
			foundFrame = gcnew List<int>(1);
		}

		bool Contains(T value) {
			return sequences->Contains(value);
		}

		property int Count {
			int get(void) {
				return sequences->Count;
			}
		}

		property T default[int]{
			T get(int idx) {
				return sequences[idx];
			}
			void set(int idx,T value) {
				if (!sequences->Contains(value)) {
					if (foundIndex == idx) found = -1;
					sequences[idx] = value;
					trigger(idx);
				}
			}
		}

			void Add(T search) {
			if (!sequences->Contains(search)) {
				sequences->Add(search);
				trigger(sequences->Count - 1);
			}
		}

		void Rem(T search) {
			if (sequences->Contains(search)) {
				int idx = sequences->IndexOf(search);
				if (foundIndex == idx) found = -1;
				sequences->Remove(search);
				trigger(-idx);
			}
		}

		void operator +=(T add) {
			Add(add);
		}

		void operator -=(T rem) {
			Rem(rem);
		}

		T operator =(T add) {
			Add(add);
			return add;
		}

		operator T() {
			return foundIndex >= 0 ? sequences[foundIndex] : nuller;
		}
	};

	// interface for parsers which search in buffers of type 'T'
	// for a given sequence of elements in blocks of type 'E'
	// (for parsing strings by passing 4 chars at once as 32bit integer elements
	// these types should be given: T as 'string', E as 'uint'
	generic<class T, class E>
	public interface class IDataParser : public IParser<E>
	{
	public:
		property SearchSequences<T>^ Sequence {
			SearchSequences<T>^ get(void) abstract;
		}
		property T FoundSequence {
			T get(void) abstract;
		}
	};

	public ref class DataSearch24
		: public IDataParser<array<byte>^, UInt24>
	{
	private:

		CryptFrame          framed;
		int                 actual;
		List<int>^ founds;
		List<array<byte>^>^ bucket;
		SearchSequences<array<byte>^>^ search;

		bool nextByte(byte nextbyte);
		void sequenceChanged(int atIndex);

	public:

		DataSearch24(void);
		DataSearch24(array<array<byte>^>^ searchVerbsSet);
		DataSearch24(array<byte>^ sequence);

		property int Offset {
			virtual int get(void) = IDataParser<array<byte>^, UInt24>::Offset::get;
		}

		property bool Found {
			virtual bool get(void);
		}

		property int FoundCount {
			virtual int get(void);
		}

		property array<byte>^ FoundSequence {
			virtual array<byte>^ get(void);
		}

		property int VerbsCount {
			virtual int get(void);
		}

		property SearchSequences<array<byte>^>^ Sequence {
			virtual SearchSequences<array<byte>^>^ get(void);
		}


		virtual void    SetSequence(int at, Object^ sequence) = IDataParser<array<byte>^, UInt24>::SetSequence;
		virtual void    AddSequence(Object^ sequence) = IDataParser<array<byte>^, UInt24>::AddSequence;
		virtual Object^ GetSequence(int at) = IDataParser<array<byte>^, UInt24>::GetSequence;
		virtual Object^ GetSequence(void) = IDataParser<array<byte>^, UInt24>::GetSequence;

		virtual int     FoundAt(int currentEnumeratorPosition);
		virtual bool    Parse(UInt24 next);
		virtual UInt24  Check(UInt24 next);
		virtual int     Next(void);
	};

	public ref class StringSearch24
		: public IDataParser<String^, UInt24>
	{
	private:

		CryptFrame                framed;
		List<array<wchar_t>^>^ bucket;
		List<int>^ founds;
		SearchSequences<String^>^ search;
		int                       actual;

		bool nextCharacter(wchar_t nextchar);
		void sequenceChanged(int atIndex);

	public:

		StringSearch24(void);
		StringSearch24(String^ searchForSequence);
		StringSearch24(array<String^>^ searchForSequences);

		property int Offset {
			virtual int get(void) = IDataParser<String^, UInt24>::Offset::get;
		}

		property bool Found {
			virtual bool get(void);
		}

		property int FoundCount {
			virtual int get(void);
		}

		property int VerbsCount {
			virtual int get(void);
		}

		property String^ FoundSequence {
			virtual String^ get(void);
		}

		property SearchSequences<String^>^ Sequence {
			virtual SearchSequences<String^>^ get(void);
		}

		virtual void    SetSequence(int at, Object^ sequence) = IDataParser<String^, UInt24>::SetSequence;
		virtual void    AddSequence(Object^ add) = IDataParser<String^, UInt24>::AddSequence;
		virtual Object^ GetSequence(int at) = IDataParser<String^, UInt24>::GetSequence;
		virtual Object^ GetSequence(void) = IDataParser<String^, UInt24>::GetSequence;

		virtual int     FoundAt(int currentFrame);
		virtual bool    Parse(UInt24 next);
		virtual UInt24  Check(UInt24 next);
		virtual int     Next(void);
	};
} //end of Yps

#endif
