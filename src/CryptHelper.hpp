/*///////////////////////////////////////////////////////////*\
||                                                           ||
||     File:      CryptHelper.hpp                            ||
||     Author:    Autogenerated                              ||
||     Generated: 28.02.2022                                 ||
||                                                           ||
\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/
#ifndef _CryptHelper_hpp_
#define _CryptHelper_hpp_


using namespace System;
using namespace Stepflow;
using namespace System::Collections;
using namespace System::Collections::Generic;
using namespace System::Runtime::InteropServices;

typedef unsigned char byte;

namespace Yps
{

	ref class CryptBuffer;

	[System::Runtime::InteropServices::StructLayoutAttribute( LayoutKind::Explicit, Size = 4 )]
	public value struct CryptFrame
	{
	public:

		[System::Runtime::InteropServices::FieldOffsetAttribute(0)]
		UInt32 b64;
		[System::Runtime::InteropServices::FieldOffsetAttribute(0)]
		UInt24 bin;

	private:

		[System::Runtime::InteropServices::FieldOffsetAttribute(0)]
		unsigned char dat;

	public:

		CryptFrame(UInt32 init) : b64(init) {}
		CryptFrame(array<unsigned char>^ init, int offset, int length);
		CryptFrame(interior_ptr<unsigned char> init, int offset, int length);

		operator UInt24% (void) {
			return bin;
		}

		property unsigned char default[int] {
			unsigned char get(int idx) { interior_ptr<unsigned char> p(&dat); return *(p + idx); }
			void set(int idx, unsigned char value) { interior_ptr<unsigned char> p(&dat); *(p + idx) = value; }
		}
	};

	public ref class CryptKey
		: public IDisposable
	{
	private:

		const static Object^ Null;
		IntPtr k;
		bool   d;
		void   dispose( bool disposing );
		CryptBuffer^ hdr;

	internal:

		CryptKey(const char* phrase);
		CryptKey(unsigned long long hashval);
		~CryptKey(void);
		void* ToPointer(void);
		bool Equals( String^ phrase );
		bool Equals( const Object^ unknown ) {
			return Equals( const_cast<Object^>( unknown ) );
		}
		CryptBuffer^ currentHdr(void);
		CryptBuffer^ currentHdr(array<UInt24>^ set);
		CryptBuffer^ currentHdr(CryptBuffer^ set);
		bool          hasHeader(void);

	public:

		const static CryptKey^ InvalidKey = gcnew CryptKey( unsigned long long int(0) );

		virtual bool IsValid( void );
		property unsigned long long Hash {
			unsigned long long get(void);
		}
		bool Equals( CryptKey^ That ) {
			if ( That ) return this->Hash == That->Hash;
			else return false;
		}
		virtual bool Equals( Object^ unknown ) override { 
			if ( unknown == nullptr ) return false;
			if ( unknown->GetType() == CryptKey::typeid ) {
				return this->Hash
				    == safe_cast<CryptKey^>( unknown )->Hash;
			} else if ( unknown->GetType() == String::typeid ) {
				this->Equals( safe_cast<String^>( unknown ) );
			} return false;
		}

		static bool operator ==( CryptKey^ This, CryptKey^ That ) {
			if ( Object::Equals( safe_cast<Object^>( This ), const_cast<Object^>( Null ) ) )
				return Object::Equals( safe_cast<Object^>( That ), const_cast<Object^>( Null ) );
			if ( Object::Equals( safe_cast<Object^>( That ), const_cast<Object^>( Null ) ) )
				return Object::Equals( safe_cast<Object^>( This ), const_cast<Object^>( Null ) );
			return This->Hash == That->Hash;
		}

		static bool operator !=( CryptKey^ This, CryptKey^ That ) {
			return !(operator==( This, That ));
		}

		String^ Encrypt( String^ string );
		String^ Decrypt( String^ crypts );

		void RemoveContext( void );
		bool Release( void );
		bool VerifyPhrase( String^ phrase ) {
			return Equals( phrase );
		}
	};

	ref class Cleansener
		: public IDisposable
	{
	private:

		static volatile int shuttingdown = 0;
		bool wirdWegGeloescht;
		void Weggeloescht( bool sollwech );

	public:
				 Cleansener();
		virtual ~Cleansener();
		static property bool Shuttown {
			bool get(void);
			void set(bool value);
		}
	};
	
	public value struct Error
	{
	private:
	
		uint    code;
		String^ text;
	
	internal:

		Error( uint eCode );
		Error( uint eCode, const char* eText );
		Error( uint eCode, const char* eText, uint ePosition );

	public:

		const static Error NoError = Error( 0u, "No Error" );

		static  String^ GetText( uint eCode );
		virtual String^ ToString( void ) override;

		property int Code { int get(void) { return (int)code; } }
		property String^ Text {	String^ get(void); }
		static operator bool( Error cast ) { return cast.code != 0; }
	};


	public ref class Base64
	{
	private:
	
		static Error error;
		static bool  check( unsigned size );
		static bool  fail( void );
		static void  Init( bool init );

	public:

		static Base64();
		
		generic<class T> where T : ValueType
		static String^   EncodeW( array<T>^ data );
		generic<class T> where T : ValueType
		static ArraySegment<T> DecodeW( String^ data );

		generic<class T> where T : ValueType
		static ArraySegment<byte> EncodeA( array<T>^ data );
		generic<class T> where T : ValueType
	    static ArraySegment<T> DecodeA( array<byte>^ data );

		static String^   EncodeString( String^ data );
		static String^   DecodeString( String^ data );

		static CryptBuffer^ Encode( CryptBuffer^ data );
		static CryptBuffer^ Encode( CryptBuffer^ data, int size );
		static CryptBuffer^ Decode( CryptBuffer^ data );
		static CryptBuffer^ Decode( CryptBuffer^ data, int size );

		static UInt32    EncodeFrame( UInt24 frame );
		static UInt24    DecodeFrame( UInt32 frame );
		
		static property Yps::Error Error {
			Yps::Error get(void) { return error; }
		}
	};
} //end of Yps

#endif
