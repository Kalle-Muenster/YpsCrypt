/*///////////////////////////////////////////////////////////*\
||                                                           ||
||     File:      CryptBuffer.cpp                            ||
||     Author:    Autogenerated                              ||
||     Generated: 28.02.2022                                 ||
||                                                           ||
\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/

#include <eszentielle/.CommandlinerTypes.h>
#include "CryptBuffer.hpp"
#include "YpsCryptApi.hpp"


Yps::CryptFrame::CryptFrame( array<unsigned char>^ init, int offset, int length )
    : CryptFrame(0)
{
    int count = 0;
    length = length > 4 ? 4 : length;
    length = Math::Min(length, init->Length - offset);
    while (length-- > 0) (*this)[count++] = init[offset++];
}

Yps::CryptFrame::CryptFrame( interior_ptr<unsigned char> init, int offset, int length )
    : CryptFrame(0)
{
    int count = 0;
    length = length > 4 ? 4 : length;
    while (length-- > 0) (*this)[count++] = *(init + offset++);
}


interior_ptr<Byte>
Yps::CryptBuffer::AsBytes( void )
{
	count = GetDataSize();
	size = 1;
	type = Byte::typeid;
	return (Byte*)data.ToPointer();
}

interior_ptr<UInt24>
Yps::CryptBuffer::AsBinary( void )
{
	count = GetDataSize() / 3;
	size = 3;
	type = UInt24::typeid;
	return (UInt24*)data.ToPointer();
}

interior_ptr<Yps::CryptFrame>
Yps::CryptBuffer::AsFrames(void)
{
	count = GetDataSize() / 4;
	size = 4;
	type = System::UInt32::typeid;
	return (CryptFrame*)data.ToPointer();
}

Yps::CryptBuffer::CryptBuffer( Array^ from )
{
	orig = from;
	type = from->GetValue(0)->GetType();
	data = Marshal::UnsafeAddrOfPinnedArrayElement( from, 0 );
	size = Marshal::SizeOf( type );
	count = from->Length;
	free = false;
}

Yps::CryptBuffer::CryptBuffer( void )
{
	type = Byte::typeid;
	data = IntPtr::Zero;
	free = false;
	count = 0;
	size = 1;
	orig = nullptr;
}

Yps::CryptBuffer::CryptBuffer( int data_size )
{
	type = Byte::typeid;
	data = Marshal::AllocCoTaskMem( data_size );
	free = true;
	count = data_size;
	size = 1;
	orig = nullptr;
}

Yps::CryptBuffer::CryptBuffer( IntPtr buffer, int data_size )
{
	type = System::Byte::typeid;
	size = 1;
	data = buffer;
	count = data_size;
	free = false;
	orig = nullptr;
}

Yps::CryptBuffer::CryptBuffer( Type^ data_type, int array_size )
{
	orig = nullptr;
	size = Marshal::SizeOf( data_type );
	count = array_size;
	array_size *= size;
	if (array_size % 3 > 0)
		array_size += (3 - (array_size % 3));
	data = Marshal::AllocCoTaskMem( array_size );
	type = data_type;
	free = true;
}

Yps::CryptBuffer::~CryptBuffer( void )
{
	if( free && data != IntPtr::Zero )
		Marshal::FreeCoTaskMem( data );
	data = IntPtr::Zero;
	orig = nullptr;
	free = false;
}

void
Yps::CryptBuffer::SetDataType( Type^ set_type )
{
	int data_size = GetDataSize();
	size = Marshal::SizeOf( set_type );
	count = data_size / size;
}

generic<class T> where T: ValueType void
Yps::CryptBuffer::SetData( array<T>^ newBuffer )
{
	if( this->free ) {
		if( this->data != IntPtr::Zero ) {
			Marshal::FreeCoTaskMem( data );
		} this->free = false;
	} this->data = Marshal::UnsafeAddrOfPinnedArrayElement( newBuffer, 0 );
	this->size = Marshal::SizeOf( this->type = T::typeid );
	this->count = newBuffer->Length;
	this->orig = newBuffer;
}

void
Yps::CryptBuffer::SetData( IntPtr ptData, int cbData )
{
	if( this->free ) {
		if (this->data != IntPtr::Zero) {
			Marshal::FreeCoTaskMem( data );
		} this->free = false;
	} this->data = ptData;
	this->count = cbData;
	this->orig = nullptr;
	this->size = 1;
	this->type = System::Byte::typeid;
}

Object^
Yps::CryptBuffer::GetData( void )
{
	return this->orig == nullptr
         ? this->data : this->orig;
}

generic<class T> where T : ValueType array<T>^
Yps::CryptBuffer::GetCopy( void )
{
	int bytesize = GetDataSize();
	int typesize = sizeof(T);
	int loopsize = bytesize / typesize;
	loopsize += (bytesize % typesize > 0 ? 1 : 0);
	void* d = data.ToPointer();
	switch (typesize) {
	case 1: { array<byte>^ copy = gcnew array<byte>(loopsize);
		byte* src = (byte*)d;
		for (int i = 0; i < loopsize; ++i)
			copy[i] = src[i];
		return reinterpret_cast<array<T>^>(copy);
	}
	case 2: { array<word>^ copy = gcnew array<word>(loopsize);
		word* src = (word*)d;
		for (int i = 0; i < loopsize; ++i)
			copy[i] = src[i];
		return reinterpret_cast<array<T>^>(copy);
	}
	case 3: { array<Stepflow::UInt24>^ copy = gcnew array<Stepflow::UInt24>(loopsize);
		Stepflow::UInt24* src = (Stepflow::UInt24*)d;
		for (int i = 0; i < loopsize; ++i)
			copy[i] = src[i];
		return reinterpret_cast<array<T>^>(copy);
	}
	case 4: { array<uint>^ copy = gcnew array<uint>(loopsize);
		uint* src = (uint*)d;
		for (int i = 0; i < loopsize; ++i)
			copy[i] = src[i];
		return reinterpret_cast<array<T>^>(copy);
	}
	case 8: { array<ulong>^ copy = gcnew array<ulong>(loopsize);
		ulong* src = (ulong*)d;
		for (int i = 0; i < loopsize; ++i)
			copy[i] = src[i];
		return reinterpret_cast<array<T>^>(copy);
	}
	} return nullptr;
}

generic<class T> where T : ValueType
Yps::CryptBuffer::Enumerator<T>^ Yps::CryptBuffer::GetEnumerator()
{
	return GetEnumerator<T>(0);
}

generic<class T> where T : ValueType
Yps::CryptBuffer::Enumerator<T>^ Yps::CryptBuffer::GetEnumerator( int offsetTs )
{
	switch ( Marshal::SizeOf<T>() ) {
	case 1: return (Enumerator<T>^)gcnew Bytes1Enumerator(this,offsetTs);
	case 3: return (Enumerator<T>^)gcnew UInt24Enumerator(this,offsetTs);
	case 4: return (Enumerator<T>^)gcnew Base64Enumerator(this,offsetTs);
	default: throw gcnew Exception("Byte, UInt24, UInt32 and CryptFrame are supported types");
	}
}

System::String^ 
Yps::CryptBuffer::ToString( void )
{
	int len = GetDataSize();
	System::Text::StringBuilder^ builder = gcnew System::Text::StringBuilder(len,len);
	interior_ptr<Byte> ptb = AsBytes();
	while(ptb[--len] == 0 && len > 0);
	++len;
	for(int i = 0; i < len; ++i, ++ptb)
		builder->Append( (wchar_t)*ptb );
	return builder->ToString();
}

void
Yps::ReleaseKey( Yps::CryptKey^ key )
{
	Yps::Crypt::ReleaseKey( key );
}


generic< class T,class C >
	where T : ValueType
	where C : ValueType
Yps::CryptBuffer::CrypticEnumerator<T,C>^
Yps::CryptBuffer::GetCrypticEnumerator( CryptKey^ use, CrypsFlags mode )
{
	return GetCrypticEnumerator<T,C>( use, mode, 0 );
}


generic< class T, class C >
	where T : ValueType
	where C : ValueType
Yps::CryptBuffer::CrypticEnumerator<T,C>^
Yps::CryptBuffer::GetCrypticEnumerator( CryptKey^ use, CrypsFlags mode, int offsetCs )
{
#pragma warning(disable: 4669)
	if (Marshal::SizeOf<T>() == Marshal::SizeOf<C>()) {
		if (mode.HasFlag(CrypsFlags::InnerCryptic))
			return  reinterpret_cast<CrypticEnumerator<T,C>^>( gcnew InnerCrypticEnumerator(this, use, offsetCs) );
		else return reinterpret_cast<CrypticEnumerator<T,C>^>( gcnew OuterCrypticEnumerator(this, use, offsetCs) );
	} else {
		if (mode.HasFlag(CrypsFlags::InnerCryptic))
			return reinterpret_cast<CrypticEnumerator<T,C>^>( gcnew InnerCrypticStringEnumerator(this, use, offsetCs) );
		else return reinterpret_cast<CrypticEnumerator<T,C>^>( gcnew OuterCrypticStringEnumerator(this, use, offsetCs) );
	} return nullptr;
#pragma warning(default: 4669) 
}


// -- inner cryptic string enumerator -- //

Yps::CryptBuffer::InnerCrypticStringEnumerator::InnerCrypticStringEnumerator( CryptBuffer^ init, CryptKey^ use, int oset )
	: CrypticEnumerator<UInt24,CryptFrame>( init, use, oset )
{
	current += (start * 3);
	Crypt::CreateHeader( use, CrypsFlags::Base64 );
	init->SetDataType( UInt24::typeid );
}

Yps::CryptBuffer::InnerCrypticStringEnumerator^
Yps::CryptBuffer::GetInnerCrypticStringEnumerator( CryptKey^ use, int offset )
{
	return gcnew InnerCrypticStringEnumerator( this, use, offset );
}

Yps::CryptFrame
Yps::CryptBuffer::InnerCrypticStringEnumerator::Current::get(void)
{
	frame.b64 = Crypt::EncryptFrame64( key, *( (UInt24*)current.ToPointer() + position ) );
	return frame;
}

void 
Yps::CryptBuffer::InnerCrypticStringEnumerator::Current::set( CryptFrame value )
{
	*((UInt24*)current.ToPointer() + position) = Crypt::DecryptFrame64( key, value.b64 );
}


// -- outer cryptic string enumerator -- //

Yps::CryptBuffer::OuterCrypticStringEnumerator^
Yps::CryptBuffer::GetOuterCrypticStringEnumerator(CryptKey^ use, int offset)
{
	return gcnew OuterCrypticStringEnumerator(this, use, offset);
}

UInt24
Yps::CryptBuffer::OuterCrypticStringEnumerator::Current::get(void)
{
	return Crypt::DecryptFrame64(key, *((UInt32*)current.ToPointer() + position));
}

void
Yps::CryptBuffer::OuterCrypticStringEnumerator::Current::set(UInt24 value)
{
	*((UInt32*)current.ToPointer() + position) = Crypt::EncryptFrame64(key, value);
}


// -- inner cryptic binar enumerator -- //

Yps::CryptBuffer::InnerCrypticEnumerator::InnerCrypticEnumerator( CryptBuffer^ init, CryptKey^ use, int oset )
	: CrypticEnumerator<UInt24,UInt24>( init, use, oset )
{
	current += (start * 3);
	Crypt::CreateHeader( use, CrypsFlags::Binary );
	init->SetDataType( UInt24::typeid );
}

Yps::CryptBuffer::InnerCrypticEnumerator^
Yps::CryptBuffer::GetInnerCrypticEnumerator(CryptKey^ use, int offset)
{
	return gcnew InnerCrypticEnumerator(this, use, offset);
}

UInt24
Yps::CryptBuffer::InnerCrypticEnumerator::Current::get(void)
{
	return Crypt::EncryptFrame24( key, *((UInt24*)current.ToPointer() + position) );
}

void
Yps::CryptBuffer::InnerCrypticEnumerator::Current::set(UInt24 value)
{
	*((UInt24*)current.ToPointer() + position) = Crypt::DecryptFrame24(key, value);
}


// -- outer cryptic binar enumerator -- //

Yps::CryptBuffer::OuterCrypticEnumerator::OuterCrypticEnumerator( CryptBuffer^ init, CryptKey^ use, int oset )
	: CrypticEnumerator<UInt24,UInt24>( init, use, oset )
{
	if( !Crypt::chkHeader24( use, use->currentHdr() ) )
		throw gcnew Exception("invalid key");
}

Yps::CryptBuffer::OuterCrypticEnumerator^
Yps::CryptBuffer::GetOuterCrypticEnumerator( CryptKey^ use, int offset )
{
	return gcnew OuterCrypticEnumerator( this, use, offset );
}

UInt24
Yps::CryptBuffer::OuterCrypticEnumerator::Current::get( void )
{
	return Crypt::DecryptFrame24( key, *( (UInt24*)current.ToPointer() + position ) );
}

void
Yps::CryptBuffer::OuterCrypticEnumerator::Current::set(UInt24 value)
{
	*((UInt24*)current.ToPointer() + position) = Crypt::EncryptFrame24( key, value );
}

