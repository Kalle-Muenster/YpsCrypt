/*///////////////////////////////////////////////////////////*\
||                                                           ||
||     File:      CryptBuffer.cpp                            ||
||     Author:    Autogenerated                              ||
||     Generated: 28.02.2022                                 ||
||                                                           ||
\*\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\*/


#include "CryptBuffer.hpp"


Yps::CryptFrame::CryptFrame( array<unsigned char>^ init, int offset, int length )
    : CryptFrame(0u)
{
    int count = 0;
    length = length > 4 ? 4 : length;
    length = Math::Min(length, init->Length - offset);
    while (length-- > 0) (*this)[count++] = init[offset++];
}

Yps::CryptFrame::CryptFrame( interior_ptr<unsigned char> init, int offset, int length )
    : CryptFrame(0u)
{
    int count = 0;
    length = length > 4 ? 4 : length;
    while (length-- > 0) (*this)[count++] = *(init + offset++);
}


interior_ptr<Byte>
Yps::CryptBuffer::AsBytes( void )
{
	count = GetDataSize();
	size = 1;
	type = Byte::typeid;
	return (Byte*)data.ToPointer();
}

interior_ptr<UInt24>
Yps::CryptBuffer::AsBinary( void )
{
	count = GetDataSize() / 3;
	size = 3;
	type = UInt24::typeid;
	return (UInt24*)data.ToPointer();
}

interior_ptr<Yps::CryptFrame>
Yps::CryptBuffer::AsFrames(void)
{
	count = GetDataSize() / 3;
	size = 3;
	type = UInt24::typeid;
	return (CryptFrame*)data.ToPointer();
}

Yps::CryptBuffer::CryptBuffer( Array^ from )
{
	type = from->GetValue(0)->GetType();
	data = Marshal::UnsafeAddrOfPinnedArrayElement( from, 0 );
	size = Marshal::SizeOf( type );
	count = from->Length;
	free = false;
}

Yps::CryptBuffer::CryptBuffer( void )
{
	type = Byte::typeid;
	data = IntPtr::Zero;
	free = false;
	count = 0;
	size = 1;
}

Yps::CryptBuffer::CryptBuffer( int data_size )
{
	type = Byte::typeid;
	data = Marshal::AllocCoTaskMem( data_size );
	free = true;
	count = data_size;
	size = 1;
}

Yps::CryptBuffer::CryptBuffer( IntPtr buffer, int data_size, Type^ data_type )
{
	type = System::Byte::typeid;
	data = buffer;
	count = data_size * size;
	free = false;
	size = 1;
}

Yps::CryptBuffer::CryptBuffer( Type^ data_type, int array_size )
{
	size = Marshal::SizeOf(data_type);
	count = array_size;
	array_size *= size;
	if (array_size % 3 > 0)
		array_size += (3 - (array_size % 3));
	data = Marshal::AllocCoTaskMem( array_size );
	type = data_type;
	free = true;
}

Yps::CryptBuffer::~CryptBuffer( void )
{
	if( free && data != IntPtr::Zero ) Marshal::FreeCoTaskMem( data );
	data = IntPtr::Zero;
	free = false;
}

void
Yps::CryptBuffer::SetDataType( Type^ set_type )
{
	int data_size = GetDataSize();
	size = Marshal::SizeOf( set_type );
	count = data_size / size;
}

generic<class T> where T : ValueType
Yps::CryptBuffer::Enumerator<T>^ Yps::CryptBuffer::GetEnumerator()
{
	return GetEnumerator<T>(0);
}

generic<class T> where T : ValueType
Yps::CryptBuffer::Enumerator<T>^ Yps::CryptBuffer::GetEnumerator(int offsetTs)
{
	switch ( Marshal::SizeOf<T>() ) {
	case 1: return (Enumerator<T>^)gcnew Bytes1Enumerator(this,offsetTs);
	case 3: return (Enumerator<T>^)gcnew UInt24Enumerator(this,offsetTs);
	case 4: return (Enumerator<T>^)gcnew Base64Enumerator(this,offsetTs);
	default: throw gcnew Exception("Byte, UInt24, UInt32 and CryptFrame are supported types");
	}
}
